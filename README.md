# 第二階段：預防性維護排程優化 (Stage II: Preventive Maintenance Scheduling)

## 1. 總覽 (Overview)

本目錄 (`second_stage_cp`) 包含用於解決「聯合生產與預防性維護排程」問題的第二階段優化程式碼。

在第一階段（假設已完成）產生一個固定的生產排程後，本階段的核心目標是：**在不嚴重影響生產效率的前提下，為每台機器智能地插入預防性維護 (Preventive Maintenance, PM) 活動，以最小化系統的總運營成本。**

這個總運營成本 `TC` (Total Cost) 由以下三部分構成：
1.  **預防性維護成本 (PM Cost)**：執行計畫性保養活動的直接成本。
2.  **預期故障成本 (Expected Failure Cost)**：因機器老化、損耗而導致的潛在故障風險所帶來的預期損失。
3.  **生產效率成本 (Makespan Cost)**：因插入維護活動可能導致的總完工時間 (Makespan) 延長所帶來的成本。

本專案的實現嚴格遵循了學術論文 `safety.pdf` 中提出的確定性優化模型。

## 2. 核心數學模型：基於風險的成本決策

本專案的理論核心是**將未來的隨機故障風險轉化為當前可計算的確定性成本**。我們不模擬機器是否「真的」在某個隨機時刻壞掉，而是採用一種基於風險管理的成本決策方法。

### 2.1. 故障率模型 (Failure Rate Model)

我們使用**動態的 Weibull 分布**來描述機器的故障行為。機器 `k` 在其生命週期中的時刻 `t` 的**故障率函數 `λ_k(t)`** 定義為：

**`λ_k(t) = (θ_k / η_k) * (t / η_k)^(θ_k - 1)`**

*注：此為 Weibull 分布的標準故障率函數 (Hazard Function)，用於描述設備在時刻 t 的瞬時故障風險。*

其中：
*   `t`: 指機器的有效運行年齡（從上次維護後開始計算）。
*   `θ_k` (Theta): **形狀參數 (Shape Parameter)**，決定了故障率曲線的基本形狀（與我之前提到的 `β` 作用相同）。
*   `η_k` (Eta): **尺度參數 (Scale Parameter)**，代表了機器的「特徵壽命」。這不是一個固定值，而是受實際工況影響的**動態參數**：

**`η_k = η_k,0 / (1 + α_uk * U_k + α_sk * S_k)`**

*   `η_k,0`: 機器的初始（或基礎）尺度參數。
*   `U_k`: 機器 `k` 的利用率。
*   `S_k`: 機器 `k` 的作業切換頻率。
*   `α_uk`, `α_sk`: 分別是利用率和切換頻率對機器損耗的影響因子。

這個動態 `η_k` 的設計至關重要，它意味著**機器用得越狠（高利用率、頻繁切換），其壽命 (`η_k`) 就越短，故障率 `λ_k(t)` 也會增長得越快**。

### 2.2. 預期故障成本 (Expected Failure Cost)

預期故障成本的計算，是透過對故障率函數 `λ_k(t)` 進行積分來實現的。在任意時間段 `[t_start, t_end]` 內，機器的**預期故障成本 `EFC`** 為：

**`EFC(t_start, t_end) = C_fk * ∫[t_start, t_end] λ_k(t) dt`**

*   `C_fk`: 機器 `k` 發生一次故障的平均維修成本。
*   `∫[t_start, t_end] λ_k(t) dt`: 該時間段內的**累積風險 (Cumulative Hazard)**，在模型中由 `get_failure_rate_integral()` 函數計算。

### 2.3. PM 的作用與成本計算週期

預防性維護 (PM) 的作用是將機器的健康狀態恢復到「宛如新生 (As good as new)」。在模型中，一旦對某台機器執行了 PM，這台機器的運行時間 `t` 將被**重置為 0**，其故障率 `λ_k(t)` 也隨之回到初始的最低點。

因此，對於一台安排了在 `t_pm` 時刻進行 PM 的機器，其總預期故障成本被切分為兩段計算：
1.  **PM 前的成本**: `EFC(0, t_pm)`
2.  **PM 後的成本**: `EFC(0, T_final - t_pm_end)`，其中 `T_final` 是該機器的最終停機時間，`t_pm_end` 是 PM 的結束時間。

### 2.4. 總成本目標函數 (Objective Function)

遺傳演算法的最終優化目標是找到一組所有機器的 PM 開始時間 `{t_pm,1, t_pm,2, ..., t_pm,K}`，使得系統總成本 `TC` 最小化：

**`min TC = Σ[k=1 to K] (C_pk) + Σ[k=1 to K] (EFC_k,before_pm + EFC_k,after_pm) + w * Makespan`**

其中：
*   `C_pk`: 機器 `k` 的預防性維護固定成本。
*   `EFC_k,before_pm`: 機器 `k` 在 PM 前的預期故障成本。
*   `EFC_k,after_pm`: 機器 `k` 在 PM 後的預期故障成本。
*   `Makespan`: 整個生產排程（包含PM活動）的總完工時間。
*   `w`: Makespan 成本的權重因子。

## 3. 程式碼結構 (Code Structure)

*   **`ga_10*5.py`**:
    *   **功能**: 使用**遺傳演算法 (Genetic Algorithm, GA)** 作為核心優化器，來尋找最佳的 PM 開始時間組合。
    *   **核心函數**:
        *   `generate_random_job_shop_schedule()`: 生成一個隨機的 10x5 生產排程用於測試。
        *   `generate_random_params()`: 為機器生成隨機的動態參數和成本參數。
        *   `get_failure_rate_integral()`: **【模型核心】** 實現了 `∫ λ_k(t) dt` 的累積風險積分計算。
        *   `evaluate_schedule_revised()`: **【優化目標】** DEAP 庫的適應度函數。它接收一個 PM 排程方案（`individual`），並根據上述的總成本目標函數計算其總成本和總完工時間。
    *   **備註**: 這是本目錄下功能最全面的主執行文件。

*   **`ga_solver.py`**:
    *   **功能**: 與 `ga_10*5.py` 類似，但使用的是一組固定的、預定義的生產排程和參數，更適用於對特定場景進行分析。

*   **`cp.py`**:
    *   **功能**: 提供了另一種求解思路，使用 Google 的 **OR-Tools CP-SAT 求解器**來解決此問題。
    *   **對比**: 與 GA 的啟發式搜索不同，CP-SAT 是一個約束規劃求解器，在問題規模較小時可能找到最佳解。這可以作為與 GA 結果對比的一個基準。

## 4. 如何運行 (How to Run)

您可以直接運行主文件 `ga_10*5.py` 來啟動遺傳演算法進行優化。

```bash
python second_stage_cp/ga_10*5.py
```

程式將執行以下步驟：
1.  生成一個隨機的 10 工件 x 5 機器的生產排程和相關參數。
2.  初始化遺傳演算法的族群。
3.  開始迭代優化，每一代都會輸出當前的最佳成本。
4.  優化結束後，將打印出找到的最佳 PM 排程方案、最低總成本和最終的完工時間。
5.  如果問題規模不大，還會生成一張包含生產排程和 PM 活動的甘特圖 `gantt_with_pm_ga.png`。